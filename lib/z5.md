# Thoughts

## Recorders

We can pass in different proxies for different occasions.

First is to record the top level path without evaluating visitor functions, let's call that the TLR (Top Level Recorder).

The TLR never has to resolve to a value as its just there to record path traversals.

The second is a VPR (Visitor Path Recorder), the VPR has to resolve to the actual value at the resolved path.  But also records
what properties were accessed.  By recording the properties we can get a complete list of dependency paths with zero ambiguity.

## TLR

e.g. for this expression:

```js
let animal = animals.use( xs => xs.find( x => x.id === id() ) )
```

We have these possible dependencies


- `id`
- `state`
- `state.animals`
- `state.animals[i]`
- `state.animals[i].id`


And nothing more.

So if someone updates `state.animals[i].nested.id`, we _know_ it wasn't referenced in any predicates, so it doesn't need to affect our `animal` query.  We can create these queries if they haven't yet been created, and cache them for later access, so there is no undefined dependency that we need to potentially lazily bind to later.

For value comparisons, we can return a value that is never equal to any other value, for now we'll use NaN, but we might use a special symbol later.

## VPR

The TLR is really simple, it just mutates a path and never needs to resolve to a value.  But the VPR needs to recursively resolve and rewrap the resolved value while also working with comparisons.

Thoeretically we don't need the VPR to record, as the recording is already doen by the TLR.  But having a VPR allows us to track branching logic based on runtime conditionals.  E.g. if a different branch runs based on Date.now or Math.random or even a state's present value, we need to know those other paths.

Unfortunately we never know if we need a VPR ahead of time, so we always need to use the VPR and never the TLR.

## Path Resolution

When a query runs, we need to resolve the value so we can provide said value to the user and they can render it.  And that query may do all kinds of transforms and other things.  And the query the user writes may be innefficient, but that's really up to them.

But beyond the evaluation of their query, we need to know which real paths in the state tree were accessed.  And that often means tracking what the user did, and converting it to a set of static (ish) paths as we go along.

E.g. if a user does:

```js
state.use(
    xs => xs.map( x => x.a ).map( x => x.b ).map( x => x.c )
)
```

We could rewrite that query and get the same result like so:

```js
state.use(
    xs => xs.map( x => x.a.b.c )
)
```

That is often called the "composition law".  In our case we want to know what paths in our state tree would require this stream to re-evaluate if they were updated.

And in our case it is these streams

- `state`
- `state[*].a`
- `state[*].a.b`
- `state[*].a.b.c`

The `[*]` indicates a traversal of a collection.  Now it doesn't matter if I map, or filter, or find, if I accessed a property in a loop, I need to know if the parent query was a static property access, or another traversal.  If it is another traversal, then we're not adding another `[*]`, we're adding properties to the prior traversal.

The exception to this is `flatMap` or nested traversals like `.map( xs => xs.map(...) )`, the nesting of collections needs to be recorded e.g.

```js
rows => rows.map(
    columns => columns.map(
        column => column.field
    )
)
```

Needs to be recorded as `state[*][*].field` because that field is within a nested list.  And if we rewrote as a flatMap, we get the same resolved path because its not about what they are doing in their operation, but about the minimum path to access a field possible.

```js
// still resolves to state[*][*].field with the flatMap
rows => rows.flatMap(
    columns => columns.map(
        column => column.field
    )
)
```

So algorithmically, how do we differentiate between what was done vs what was accessed.  If we're mapping, and we previously weren't mapping (or traversing a collection) then we must currently be targetting a real list that lives somewhere in the state tree, instead of a computed list.

Well, not true, what if we do this:

```js
state.use(
    xs => xs.map( x => ({ nested: { field: x } }) ).map( x => x.nested.field.x.actual )
)
```

But here, when we wrap our data in an object, that object is not a tracked proxy.  So our map is deemed to have returned some foreign data or decoration of data.

It's not until we reference the proxy again at `x.actual` that we resume tracking.

So the final realised path is 

```js
state[*].actual
```